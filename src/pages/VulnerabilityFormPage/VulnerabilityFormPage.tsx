import { useCallback, useEffect, useState } from "react";
import { useNetwork } from "wagmi";
import axios from "axios";
import { getAppVersion } from "utils";
import { LocalStorage } from "constants/constants";
import { useVaults } from "hooks/vaults/useVaults";
import { DEFAULT_BOT } from "settings";
import { calcCid } from "pages/VulnerabilityFormPage/encrypt";
import { VulnerabilityFormContext, VULNERABILITY_INIT_DATA } from "./store";
import { BotStatus, IVulnerabilityData, VulnerabilityStep } from "./types";
// Components
import VulnerabilityFormCard from "./VulnerabilityFormCard/VulnerabilityFormCard";
import ProjectSelect from "./FormSteps/ProjectSelect/ProjectSelect";
import ContactInfo from "./FormSteps/ContactInfo/ContactInfo";
import VulnerabilityDescription from "./FormSteps/VulnerabilityDescription/VulnerabilityDescription";
import TermsAndProcess from "./FormSteps/TermsAndProcess/TermsAndProcess";
import VulnerabilitySubmit from "./FormSteps/VulnerabilitySubmit/VulnerabilitySubmit";
import { StyledVulnerabilityFormPage } from "./styles";
import { LogClaimContract } from "contracts";
import { useOnChange } from "hooks/usePrevious";
import { waitForTransaction } from "@wagmi/core";

const steps = [
  { title: "SELECT PROJECT", component: ProjectSelect, card: VulnerabilityStep.project },
  { title: "CONTACT INFORMATION", component: ContactInfo, card: VulnerabilityStep.contact },
  { title: "DESCRIBE VULNERABILITY", component: VulnerabilityDescription, card: VulnerabilityStep.description },
  { title: "TERMS AND PROCESS", component: TermsAndProcess, card: VulnerabilityStep.terms },
  { title: "SUBMIT", component: VulnerabilitySubmit, card: VulnerabilityStep.submission },
];

const VulnerabilityFormPage = () => {
  const { vaults } = useVaults();
  const { chain } = useNetwork();
  const [currentStep, setCurrentStep] = useState<number>();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submissionTxSucceed, setSubmissionTxSucceed] = useState<null | boolean>(null);
  const [vulnerabilityData, setVulnerabilityData] = useState<IVulnerabilityData>();
  const vault = (vaults ?? []).find((vault) => vault.id === vulnerabilityData?.project?.projectId);

  const submitVulnerabilityCall = LogClaimContract.hook(vault);
  const submitVulnerabilityCallStatus = submitVulnerabilityCall.status;

  const reset = () => {
    setVulnerabilityData(VULNERABILITY_INIT_DATA);
    setIsSubmitting(false);
    setCurrentStep(0);
    setSubmissionTxSucceed(null);
  };

  // Loads initial state of the vault
  useEffect(() => {
    if (!vaults) return;
    try {
      let cachedData: IVulnerabilityData = JSON.parse(
        localStorage.getItem(LocalStorage.SubmitVulnerability) || JSON.stringify(VULNERABILITY_INIT_DATA)
      );

      if (cachedData.submission?.chainId !== chain?.id) {
        setVulnerabilityData(VULNERABILITY_INIT_DATA);
      } else if (cachedData.project?.projectId && !vaults?.find((vault) => vault.id === cachedData.project?.projectId)) {
        setVulnerabilityData(VULNERABILITY_INIT_DATA);
      } else if (cachedData.version !== getAppVersion()) {
        setVulnerabilityData(VULNERABILITY_INIT_DATA);
      } else {
        setVulnerabilityData(cachedData);
      }
    } catch (e) {
      setVulnerabilityData(VULNERABILITY_INIT_DATA);
    }
  }, [vaults, chain]);

  // Save data to local storage
  useEffect(() => {
    localStorage.setItem(LocalStorage.SubmitVulnerability, JSON.stringify(vulnerabilityData));
  }, [vulnerabilityData]);

  // Finds current step and set it
  useEffect(() => {
    if (!vulnerabilityData) return;
    const index = steps.findIndex((step) => !vulnerabilityData[`${VulnerabilityStep[step.card]}`]);
    if (index === -1) setCurrentStep(steps.length - 1);
    else setCurrentStep(index);
  }, [vulnerabilityData]);

  useOnChange(submitVulnerabilityCallStatus, async (newStatus, _) => {
    if (["loading", "success"].includes(newStatus)) {
      setIsSubmitting(true);

      if (newStatus === "success") {
        try {
          const txReceipt = await waitForTransaction({ wait: submitVulnerabilityCall.data?.wait });
          setIsSubmitting(false);

          if (txReceipt.status === 0) {
            setSubmissionTxSucceed(false);
            return;
          }

          if (vulnerabilityData && submitVulnerabilityCall.data?.hash && chain?.id) {
            const newVulnerabilityData = {
              ...vulnerabilityData,
              submission: {
                verified: true,
                botStatus: BotStatus.Pending,
                transactionHash: submitVulnerabilityCall.data.hash,
                chainId: chain?.id,
              },
            };

            setVulnerabilityData(newVulnerabilityData);
            sendTransactionToBot(newVulnerabilityData);
          }
        } catch (error) {
          setSubmissionTxSucceed(false);
          setIsSubmitting(false);
        }
      }
    } else {
      setIsSubmitting(false);
    }
  });

  const sendTransactionToBot = useCallback(async (data: IVulnerabilityData) => {
    if (!data) return;
    try {
      const payload = {
        txHash: data.submission?.transactionHash,
        chainId: data.submission?.chainId,
        msg: data.description?.encryptedData,
        route: data.project?.projectName,
        contractAddress: data.project?.contractAddress,
      };

      const res = await axios.post(DEFAULT_BOT, payload);

      if (res.status === 200) {
        setVulnerabilityData((prev) => {
          return { ...prev!, submission: { ...prev!.submission!, botStatus: BotStatus.Success } };
        });
      } else {
        setVulnerabilityData((prev) => {
          return { ...prev!, submission: { ...prev!.submission!, botStatus: BotStatus.Fail } };
        });
      }
    } catch {
      setVulnerabilityData((prev) => {
        return { ...prev!, submission: { ...prev!.submission!, botStatus: BotStatus.Fail } };
      });
    }
  }, []);

  const submitVulnerability = useCallback(async () => {
    if (!vulnerabilityData?.description?.encryptedData) return;
    const encryptedData = vulnerabilityData?.description?.encryptedData;
    submitVulnerabilityCall.send(await calcCid(encryptedData));
  }, [submitVulnerabilityCall, vulnerabilityData]);

  const context = {
    reset,
    currentStep,
    setCurrentStep,
    vulnerabilityData,
    setVulnerabilityData,
    submitVulnerability,
    sendTransactionToBot,
    submissionTxSucceed,
    submittingVulnerability: isSubmitting,
  };

  return (
    <StyledVulnerabilityFormPage className="content-wrapper">
      <div id="vulnerabilityFormWrapper" className="accordion-wrapper">
        <VulnerabilityFormContext.Provider value={context}>
          {steps.map((step, index) => (
            <VulnerabilityFormCard
              extraInfoTitle={index === 0 ? vulnerabilityData?.project?.projectName : ""}
              id={index}
              key={index}
              title={step.title}
              collapsed={currentStep !== index}
              card={step.card}
              verified={vulnerabilityData?.[VulnerabilityStep[step.card]] !== undefined}
              disabled={isSubmitting}>
              {<step.component />}
            </VulnerabilityFormCard>
          ))}
        </VulnerabilityFormContext.Provider>
      </div>
    </StyledVulnerabilityFormPage>
  );
};

export { VulnerabilityFormPage };
