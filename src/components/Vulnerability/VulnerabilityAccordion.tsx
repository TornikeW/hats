import { createContext, Dispatch, SetStateAction, useCallback, useEffect, useState } from "react";
import "../../styles/Vulnerability/VulnerabilityAccordion.scss";
import AccordionCard from "./AccordionCard";
import ProjectSelect from "./ProjectSelect/ProjectSelect";
import Description from "./Description";
import ContactInfo from "./ContactInfo";
import TermsAndProcess from "./TermsAndProcess/TermsAndProcess";
import Submit from "./Submit/Submit";
import { getAppVersion } from "../../utils";
import { LocalStorage } from "../../constants/constants";
import { Card, IVulnerabilityData } from "./types";
import { useEthers, useTransactions } from "@usedapp/core";
import { useVaults } from "hooks/useVaults";
import { BotStatus } from "./Submit/components/SubmitSuccess/SubmitSuccess";
import axios from "axios";
import { DEFAULT_BOT } from "settings";
import { useClaim } from "hooks/contractHooks";
import { usePrevious } from "hooks/usePrevious";
import { calcCid } from "./encrypt";
const packageJSON = require("../../../package.json");

const steps = [
  { title: "SELECT PROJECT", component: ProjectSelect, card: Card.project },
  { title: "CONTACT INFORMATION", component: ContactInfo, card: Card.contact },
  { title: "DESCRIBE VULNERABILITY", component: Description, card: Card.description },
  { title: "TERMS AND PROCESS", component: TermsAndProcess, card: Card.terms },
  { title: "SUBMIT", component: Submit, card: Card.submission },
];

interface IAccordionContext {
  currentStep?: number
  submittingVurnability: boolean
  cards: IVulnerabilityData | undefined
  setCards: Dispatch<SetStateAction<IVulnerabilityData | undefined>>
  nextCard: Function
  setCurrentStep: Dispatch<SetStateAction<number | undefined>>
  submitVurnability: Function
  sendTransactionToBot: Function
  reset: Function
}
export const AccordionContext = createContext<IAccordionContext>(undefined as any);

export const VULNERABILITY_INIT_DATA: IVulnerabilityData = {
  version: packageJSON.version
};

export default function VulnerabilityAccordion() {
  const submittingVurnability = useTransactions().transactions.some(tx => !tx.receipt)
  const [currentStep, setCurrentStep] = useState<number>();
  const [cards, setCards] = useState<IVulnerabilityData>();
  const { vaults } = useVaults();
  const vault = vaults?.find(vault => vault.id === cards?.project?.projectId);
  const { chainId } = useEthers();

  useEffect(() => {
    let cachedData: IVulnerabilityData = JSON.parse(localStorage.getItem(LocalStorage.SubmitVulnerability) || JSON.stringify(VULNERABILITY_INIT_DATA));
    if (cachedData.version !== getAppVersion()) {
      setCards(VULNERABILITY_INIT_DATA);
    } else {
      setCards(cachedData);
    }
  }, [])

  useEffect(() => {
    localStorage.setItem(LocalStorage.SubmitVulnerability, JSON.stringify(cards));
  }, [cards])

  const reset = () => {
    setCards(VULNERABILITY_INIT_DATA);
  }

  const nextCard = () => {
  }

  const sendTransactionToBot = useCallback(async () => {
    if (!cards) return;
    try {
      const payload = {
        msg: cards.description?.encryptedData,
        txHash: cards.submission?.transactionHash,
        chainId: cards.submission?.chainId,
        route: cards.project?.projectName,
        contractAddress: cards.project?.contractAddress,
      };

      await axios.post(DEFAULT_BOT, payload);
      setCards(prev => {
        return { ...prev!, submission: { ...prev!.submission!, botStatus: BotStatus.Success } };
      });
    } catch {
      setCards(prev => {
        return { ...prev!, submission: { ...prev!.submission!, botStatus: BotStatus.Fail } };
      });
    }
  }, [cards]);

  const { send: submit, state: submitState } = useClaim(vault?.master.address)
  const prevSubmitState = usePrevious(submitState);

  const submitVurnability = useCallback(async () => {
    const encryptedData = cards?.description?.encryptedData;
    submit(await calcCid(encryptedData));
  }, [submit, cards])

  useEffect(() => {
    if (submitState.status !== prevSubmitState?.status && submitState.status === 'Success' && chainId) {
      setCards(prev => {
        if (prev && submitState.receipt?.transactionHash) {
          prev.submission = {
            verified: false,
            botStatus: BotStatus.Pending,
            transactionHash: submitState.receipt?.transactionHash!,
            chainId: submitState.chainId!,
          };
          return prev;
        }
      });
      sendTransactionToBot();
    }
  }, [submitState.status, submitState.chainId, vault, submitState.receipt?.transactionHash,
    sendTransactionToBot, chainId, prevSubmitState?.status, cards?.project?.contractAddress]);

  useEffect(() => {
    if (!cards) return;
    const index = steps.findIndex(step => !cards[`${Card[step.card]}`])
    if (index === -1) setCurrentStep(steps.length - 1);
    else setCurrentStep(index);
  }, [cards])

  const context = {
    currentStep,
    setCurrentStep,
    cards,
    setCards,
    submittingVurnability,
    submitVurnability,
    nextCard,
    sendTransactionToBot,
    reset
  }

  return (
    <div className="content vulnerability-wrapper">
      <div id="accrodionWrapper" className="accrodion-wrapper">
        <AccordionContext.Provider value={context}>
          {steps.map((step, index) => (
            <AccordionCard
              extraInfoTitle={index === 0 ? cards?.project?.projectName : ""}
              id={index}
              key={index}
              title={step.title}
              collapsed={currentStep !== index}
              card={step.card}
              verified={cards?.[Card[step.card]] !== undefined}
              disabled={submittingVurnability} >
              {<step.component />}
            </AccordionCard>))}
        </AccordionContext.Provider>
      </div>
    </div>
  );
}
